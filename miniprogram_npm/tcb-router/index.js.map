{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["class TcbRouter {\n\n    constructor({ event = {} } = {}) {\n\n        // 中间件\n        this._routerMiddlewares = {};\n        this._req = { event, url: event.$url };\n        this._res = {};\n    }\n\n    /**\n     * add path to _routerMiddlewares\n     * @param {String} path\n     */\n    _addRoute(path) {\n        if (!this._routerMiddlewares.hasOwnProperty(path)) {\n            this._routerMiddlewares[path] = {\n                middlewares: []\n            };\n        }\n    }\n\n    /**\n     * add middleware to _routerMiddlewares\n     * @param {String|Array} path\n     * @param {Function} middleware\n     */\n    _addMiddleware(path, middleware) {\n        let paths = [];\n\n        if (Array.isArray(path)) {\n            paths = path;\n        }\n        else {\n            paths = [path];\n        }\n\n        paths.forEach((p) => {\n            this._addRoute(p);\n            this._routerMiddlewares[p].middlewares.push(middleware);\n        });\n    }\n\n    /**\n     * use middleware for all routes\n     * @param {String} path\n     * @param {Function} middleware\n     */\n    use() {\n        let path = null;\n        let handler = null;\n\n        if (arguments.length === 1) {\n            path = '*';\n            handler = arguments[0];\n        }\n        else if (arguments.length > 1) {\n            path = arguments[0];\n            handler = arguments[1];\n        }\n\n        if (typeof handler !== 'function') {\n            return console.warn('Handler should be a function. The middleware is not installed correctly.');\n        }\n\n        this._addMiddleware(path, handler);\n    }\n\n    /**\n     * set routes\n     * @param {String|Array} path \n     * @param {Function} middleware\n     */\n    router(path = '*') {\n\n        for (let i = 1, len = arguments.length; i < len; i++) {\n            let handler = arguments[i];\n            if (typeof handler !== 'function') {\n                return console.warn('Handler should be a function. The middleware is not installed correctly.');\n            }\n\n            this._addMiddleware(path, handler);\n        }\n    }\n\n    /**\n     * start the route server\n     */\n    serve() {\n\n        let _routerMiddlewares = this._routerMiddlewares;\n        let url = this._req.url;\n\n        // try to  match path\n        if (_routerMiddlewares.hasOwnProperty(url)\n            || _routerMiddlewares.hasOwnProperty('*')) {\n            let middlewares = (_routerMiddlewares[url]) ? _routerMiddlewares[url].middlewares : [];\n            // put * path middlewares on the queue head\n            if (_routerMiddlewares['*']) {\n                middlewares = [].concat(_routerMiddlewares['*'].middlewares, middlewares);\n            }\n\n            const fn = compose(middlewares);\n\n            return new Promise((resolve, reject) => {\n                fn(this).then((res) => {\n                    resolve(this.body);\n                }).catch(reject);\n            });\n        }\n        else {\n            return new Promise((resolve) => {\n                resolve();\n            });\n        }\n\n    }\n}\n\nfunction compose(middleware) {\n    if (!Array.isArray(middleware)) {\n        throw new TypeError('Middleware must be an array!');\n    }\n    for (const fn of middleware) {\n        if (typeof fn !== 'function') {\n            throw new TypeError('Handler should be a function. The middleware is not installed correctly.');\n        }\n    }\n\n    /**\n     * @param {Object} context\n     * @return {Promise}\n     * @api public\n     */\n\n    return function (context, next) {\n        // parameter 'next' is empty when this the main flow\n        // last called middleware #\n        let index = -1;\n\n        // dispatch the first middleware\n        return dispatch(0);\n\n        function dispatch(i) {\n            if (i <= index) {\n                return Promise.reject(new Error('next() called multiple times'));\n            }\n\n            index = i;\n\n            // get the handler and path of the middlware\n            let handler = middleware[i];\n\n            // reach the end, call the last handler \n            if (i === middleware.length) {\n                handler = next;\n            }\n\n            // if handler is missing, just return Promise.resolve\n            if (!handler) {\n                return Promise.resolve();\n            }\n\n            try {\n                // handle request, call handler one by one using dispatch\n                // Promise.resolve will help trigger the handler to be invoked\n                return Promise.resolve(handler(context, dispatch.bind(null, i + 1)));\n            }\n            catch (err) {\n                return Promise.reject(err);\n            }\n        }\n    }\n}\n\nmodule.exports = TcbRouter;"]}